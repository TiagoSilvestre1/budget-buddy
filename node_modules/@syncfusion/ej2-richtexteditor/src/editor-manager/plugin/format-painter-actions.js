import { closest, createElement, detach, isNullOrUndefined as isNOU, removeClass } from '@syncfusion/ej2-base';
import * as EVENTS from '../../common/constant';
import { SelectionCommands } from '../plugin';
var FormatPainterActions = /** @class */ (function () {
    function FormatPainterActions(parent, options) {
        this.parent = parent;
        this.settings = options;
        this.addEventListener();
        this.setDeniedFormats();
    }
    FormatPainterActions.prototype.addEventListener = function () {
        this.parent.observer.on(EVENTS.FORMAT_PAINTER_ACTIONS, this.actionHandler, this);
    };
    FormatPainterActions.prototype.actionHandler = function (args) {
        if (!isNOU(args) && !isNOU(args.item) && !isNOU(args.item.formatPainterAction)) {
            switch (args.item.formatPainterAction) {
                case 'format-copy':
                    this.copyAction();
                    break;
                case 'format-paste':
                    this.pasteAction();
                    break;
                case 'escape':
                    this.escapeAction();
                    break;
            }
        }
    };
    FormatPainterActions.prototype.generateElement = function () {
        var copyCollection = this.copyCollection.slice(); // To clone without reversing the collcection array
        copyCollection.reverse();
        var length = copyCollection.length;
        var elemCollection = createElement('div', { className: 'e-format-paste-wrapper' });
        var lastAppendChild;
        for (var i = 0; i < length; i++) {
            var _a = copyCollection[i], attrs = _a.attrs, className = _a.className, styles = _a.styles, tagName = _a.tagName;
            var elem = createElement(tagName);
            if (className !== '') {
                elem.className = className;
            }
            for (var i_1 = 0; i_1 < attrs.length; i_1++) {
                var property = attrs[i_1].name;
                var value = attrs[i_1].value;
                elem.setAttribute(property, value);
            }
            for (var i_2 = 0; i_2 < styles.length; i_2++) {
                var property = styles[i_2].property;
                var value = styles[i_2].value;
                var priority = styles[i_2].priority;
                elem.style.setProperty(property, value, priority);
            }
            if (elemCollection.childElementCount === 0) {
                elemCollection.append(elem);
                lastAppendChild = elem;
            }
            else {
                lastAppendChild.append(elem);
                lastAppendChild = elem;
            }
        }
        var elemChild = this.removeDeniedFormats(elemCollection);
        var currentElem = elemChild;
        while (currentElem) {
            if (currentElem.firstChild === null) {
                lastAppendChild = currentElem;
                currentElem = undefined;
            }
            else {
                currentElem = currentElem.firstChild;
            }
        }
        this.newElem = elemChild;
        this.newElemLastChild = lastAppendChild;
    };
    FormatPainterActions.prototype.pasteAction = function () {
        if (isNOU(this.copyCollection) || this.copyCollection.length === 0) {
            this.paintPlainTextFormat();
            return;
        }
        this.insertFormatNode(this.newElem, this.newElemLastChild);
        this.parent.undoRedoManager.saveData();
    };
    FormatPainterActions.prototype.removeDeniedFormats = function (parentElement) {
        if (!isNOU(this.deniedFormatsCollection) && this.deniedFormatsCollection.length > 0) {
            var deniedPropArray = this.deniedFormatsCollection;
            var length_1 = deniedPropArray.length;
            for (var i = 0; i < length_1; i++) {
                var tag = deniedPropArray[i].tag;
                if (deniedPropArray[i].tag) {
                    var elementsList = parentElement.querySelectorAll(tag);
                    for (var j = 0; j < elementsList.length; j++) {
                        if (deniedPropArray[i].classes.length > 0) {
                            var classes = deniedPropArray[i].classes;
                            var classLength = classes.length;
                            for (var k = 0; k < classLength; k++) {
                                if (elementsList[j].classList.contains(classes[k])) {
                                    removeClass([elementsList[j]], classes[k]);
                                }
                            }
                            if (elementsList[j].classList.length === 0) {
                                elementsList[j].removeAttribute('class');
                            }
                        }
                        if (deniedPropArray[i].styles.length > 0) {
                            var styles = deniedPropArray[i].styles;
                            var styleLength = styles.length;
                            for (var k = 0; k < styleLength; k++) {
                                elementsList[j].style.removeProperty(styles[k]);
                            }
                            if (elementsList[j].style.length === 0) {
                                elementsList[j].removeAttribute('style');
                            }
                        }
                        if (deniedPropArray[i].attributes.length > 0) {
                            var attributes = deniedPropArray[i].attributes;
                            var attributeLength = attributes.length;
                            for (var k = 0; k < attributeLength; k++) {
                                elementsList[j].removeAttribute(attributes[k]);
                            }
                        }
                    }
                }
            }
        }
        return parentElement.firstElementChild;
    };
    FormatPainterActions.prototype.copyAction = function () {
        var copyCollection = [];
        var range = this.parent.nodeSelection.getRange(document);
        var parentElem = range.startContainer.parentElement;
        var currentContext = this.findCurrentContext(parentElem);
        var allowedRulesArray = this.settings.allowedFormats.split(';');
        for (var i = 0; i < allowedRulesArray.length; i++) {
            allowedRulesArray[i] = allowedRulesArray[i].trim();
        }
        var _a = this.getRangeParentElem(currentContext, range), rangeParentElem = _a[0], context = _a[1];
        if (currentContext === null) {
            currentContext = context;
        }
        if (!isNOU(currentContext) && this.settings.allowedContext.indexOf(currentContext) > -1) {
            if (range.startContainer.nodeName === '#text') {
                parentElem = range.startContainer.parentElement;
            }
            var lastElement = parentElem;
            do {
                if (allowedRulesArray.indexOf(parentElem.nodeName.toLowerCase()) > -1) {
                    var allAttributes = parentElem.attributes;
                    var attribute = [];
                    for (var i = 0; i < allAttributes.length; i++) {
                        if (allAttributes[i].name !== 'class' && allAttributes[i].name !== 'style') {
                            attribute.push(allAttributes[i]);
                        }
                    }
                    var classes = parentElem.className;
                    var allStyles = parentElem.style;
                    var styleProp = [];
                    for (var i = 0; i < allStyles.length; i++) {
                        var property = allStyles[i];
                        var value = allStyles.getPropertyValue(property);
                        var priority = allStyles.getPropertyPriority(property);
                        styleProp.push({ property: property, value: value, priority: priority });
                    }
                    copyCollection.push({
                        attrs: attribute, className: classes, styles: styleProp, tagName: parentElem.nodeName
                    });
                }
                if (rangeParentElem === parentElem) {
                    parentElem = undefined;
                }
                else if (!isNOU(parentElem.parentElement)) {
                    parentElem = parentElem.parentElement;
                }
                if (lastElement === parentElem) {
                    break;
                }
            } while (!isNOU(parentElem) || parentElem === this.parent.editableElement);
            this.copyCollection = copyCollection;
        }
        this.generateElement();
    };
    FormatPainterActions.prototype.getRangeParentElem = function (currentContext, range) {
        var startContainer = range.startContainer;
        var rangeParentELem;
        if (startContainer.nodeType === 3) {
            startContainer = startContainer.parentElement;
        }
        switch (currentContext) {
            case 'Table':
                rangeParentELem = closest(startContainer, 'td');
                if (isNOU(rangeParentELem)) {
                    rangeParentELem = closest(startContainer, 'th');
                }
                break;
            case 'List':
                rangeParentELem = closest(startContainer, 'li');
                break;
            case 'Text':
                rangeParentELem = closest(startContainer, 'p');
                break;
        }
        if (isNOU(rangeParentELem)) {
            var nearBlockParentName = this.getNearestBlockParentElement(range);
            if (!isNOU(nearBlockParentName) && nearBlockParentName !== 'UL' &&
                nearBlockParentName !== 'OL' && nearBlockParentName !== 'LI') {
                rangeParentELem = closest(startContainer, nearBlockParentName);
                currentContext = 'Text';
            }
        }
        if (currentContext === 'List') {
            rangeParentELem = rangeParentELem.parentElement;
        }
        return [rangeParentELem, currentContext];
    };
    FormatPainterActions.prototype.getNearestBlockParentElement = function (range) {
        var node = range.commonAncestorContainer;
        if (node.nodeType === 3) {
            node = node.parentNode;
        }
        // iterate untill the content editable div
        while (node && node !== this.parent.editableElement) {
            // If true return the block node name.
            if (!isNOU(node) && this.isBlockElement(node)) {
                return node.nodeName;
            }
            // if false re assign node to parent node
            node = node.parentNode;
        }
        return null;
    };
    FormatPainterActions.prototype.isBlockElement = function (node) {
        var blockTags = ['P', 'DIV', 'UL', 'OL', 'LI', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6',
            'ADDRESS', 'ARTICLE', 'ASIDE', 'BLOCKQUOTE', 'FIGCAPTION', 'FIGURE', 'FOOTER', 'HEADER',
            'HR', 'MAIN', 'NAV', 'SECTION', 'SUMMARY', 'PRE'];
        return blockTags.indexOf(node.nodeName) > -1;
    };
    FormatPainterActions.prototype.escapeAction = function () {
        this.copyCollection = [];
    };
    FormatPainterActions.prototype.paintPlainTextFormat = function () {
        var range = this.parent.nodeSelection.getRange(this.parent.currentDocument);
        var domSelection = this.parent.nodeSelection;
        var nodes = range.collapsed ? domSelection.getSelectionNodeCollection(range) :
            domSelection.getSelectionNodeCollectionBr(range);
        var isInValid;
        if (nodes.length > 1) {
            for (var i = 0; i < nodes.length; i++) {
                isInValid = this.validateELementTag(nodes[i]);
            }
        }
        else {
            isInValid = this.validateELementTag(range.startContainer) && this.validateELementTag(range.endContainer);
        }
        if (!isInValid) {
            this.parent.execCommand('Clear', 'ClearFormat', null, null);
        }
    };
    FormatPainterActions.prototype.validateELementTag = function (node) {
        var INVALID_TAGS = ['A', 'AUDIO', 'IMG', 'VIDEO', 'IFRAME'];
        if (node.nodeType === 3) {
            node = node.parentElement;
        }
        return INVALID_TAGS.indexOf(node.tagName) > -1;
    };
    FormatPainterActions.prototype.findCurrentContext = function (parentElem) {
        if (closest(parentElem, 'td') || closest(parentElem, 'tr') || closest(parentElem, 'tbody')) {
            return 'Table';
        }
        else if (closest(parentElem, 'li')) {
            return 'List';
        }
        else if (closest(parentElem, 'p')) {
            return 'Text';
        }
        return null;
    };
    FormatPainterActions.prototype.insertFormatNode = function (elem, lastChild) {
        var endNode = this.parent.editableElement;
        var docElement = this.parent.currentDocument;
        var domSelection = this.parent.nodeSelection;
        var clonedElem = elem.cloneNode(true);
        var childElem = clonedElem.firstChild;
        var inlineElement;
        while (childElem) {
            if (this.isBlockElement(childElem)) {
                childElem = childElem.firstChild;
            }
            else {
                inlineElement = childElem.parentNode.removeChild(childElem);
                break;
            }
        }
        var formatValues = {
            element: inlineElement,
            lastChild: lastChild
        };
        SelectionCommands.applyFormat(docElement, null, endNode, 'P', 'formatPainter', null, formatValues);
        var isFullNodeSelected;
        var range = this.parent.nodeSelection.getRange(docElement);
        var isCollapsed = range.collapsed;
        var nodes = range.collapsed ? domSelection.getSelectionNodeCollection(range) :
            domSelection.getSelectionNodeCollectionBr(range);
        if (nodes.length === 1) {
            while (!this.isBlockElement(nodes[0])) {
                nodes[0] = nodes[0].parentElement;
            }
            isFullNodeSelected = nodes[0].textContent.trim() === range.commonAncestorContainer.wholeText.trim();
        }
        if (this.isBlockElement(elem) && isCollapsed || nodes.length > 1 || isFullNodeSelected) {
            this.insertBlockNode(elem, range, docElement, endNode, nodes);
        }
    };
    FormatPainterActions.prototype.insertBlockNode = function (element, range, docElement, endNode, nodes) {
        var domSelection = this.parent.nodeSelection;
        var listElement; // To clone to multiple list elements
        var cloneListParentNode;
        if (element.nodeName === 'UL' || element.nodeName === 'OL') {
            cloneListParentNode = element.cloneNode(true);
            listElement = cloneListParentNode.firstChild;
        }
        var textNode = range.startContainer; // To set cursor position
        for (var index = 0; index < nodes.length; index++) {
            var lastTextNode = nodes[index];
            if (nodes[index].nodeType === 3) {
                nodes[index] = nodes[index].parentElement;
            }
            while (!this.isBlockElement(nodes[index])) {
                nodes[index] = nodes[index].parentElement;
            }
            var cloneParentNode = void 0;
            if (!isNOU(cloneListParentNode)) {
                cloneParentNode = listElement.cloneNode(true);
            }
            else {
                cloneParentNode = element.cloneNode(true);
            }
            // Appending all the child elements
            while (nodes[index].firstChild) {
                if (cloneParentNode.nodeName === 'LI') {
                    cloneParentNode.appendChild(nodes[index].firstChild);
                }
                else {
                    // Except list nodes other block nodes replaced here
                    if (nodes[index].nodeType === 3) {
                        cloneParentNode.appendChild(nodes[index].firstChild);
                    }
                    else {
                        cloneParentNode.innerHTML = nodes[index].innerHTML;
                        nodes[index].innerHTML = '';
                    }
                    nodes[index] = nodes[index].parentNode.replaceChild(cloneParentNode, nodes[index]);
                }
            }
            if (cloneParentNode.nodeName === 'LI') {
                // Appending the li nodes to the ol or ul node
                cloneListParentNode.append(cloneParentNode);
                if (index === 0) {
                    var nodeName = nodes[index].nodeName;
                    nodes[index] = nodes[index].parentNode.replaceChild(cloneListParentNode, nodes[index]);
                    var parent_1 = nodeName === 'LI' ? cloneListParentNode.parentElement
                        : cloneListParentNode;
                    // Splicing and then inserting the node to previous element sibling of the Listparent.parent
                    this.parent.nodeCutter.SplitNode(range, parent_1, true);
                    if (!isNOU(parent_1.previousElementSibling)) {
                        parent_1.parentNode.insertBefore(cloneListParentNode, parent_1.nextElementSibling);
                    }
                    else {
                        parent_1.parentElement.insertBefore(cloneListParentNode, parent_1);
                    }
                }
                detach(nodes[index]);
            }
            /**Removing the inserted block node in list and appending to previous element sibling */
            if (cloneParentNode.nodeName !== 'LI' && (cloneParentNode.parentElement.nodeName === 'OL' ||
                cloneParentNode.parentElement.nodeName === 'UL')) {
                var parent_2 = cloneParentNode.parentElement;
                // Cutting single ul or ol to two ul or ol based on the range
                this.parent.nodeCutter.SplitNode(range, parent_2, true);
                if (!isNOU(parent_2.previousElementSibling)) {
                    parent_2.previousElementSibling.after(cloneParentNode);
                }
                else {
                    parent_2.parentElement.prepend(cloneParentNode);
                }
            }
            nodes[index] = lastTextNode;
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-expressions
        !isNOU(listElement) ? detach(listElement) : false;
        this.cleanEmptyLists();
        if (nodes.length > 1) {
            var startSelectNode = nodes[0];
            var endSelectNode = nodes[nodes.length - 1];
            domSelection.setSelectionText(docElement, startSelectNode, endSelectNode, 0, endSelectNode.textContent.length);
        }
        else {
            domSelection.setCursorPoint(docElement, textNode, textNode.textContent.length);
        }
    };
    FormatPainterActions.prototype.cleanEmptyLists = function () {
        var listElem = this.parent.editableElement.querySelectorAll('ol, ul');
        for (var i = 0; i < listElem.length; i++) {
            if (listElem[i].textContent.trim() === '') {
                detach(listElem[i]);
            }
        }
    };
    FormatPainterActions.prototype.setDeniedFormats = function () {
        var deniedFormatsCollection = [];
        if (isNOU(this.settings) || isNOU(this.settings.deniedFormats)) {
            return;
        }
        var deniedFormats = this.settings.deniedFormats.split(';');
        var length = deniedFormats.length;
        for (var i = 0; i < length; i++) {
            var formatString = deniedFormats[i];
            if (formatString !== '') {
                formatString.trim();
                var collection = this.makeDeniedFormatsCollection(formatString);
                if (!isNOU(collection)) {
                    deniedFormatsCollection.push(collection);
                }
            }
        }
        this.deniedFormatsCollection = deniedFormatsCollection;
    };
    FormatPainterActions.prototype.makeDeniedFormatsCollection = function (value) {
        var openParenIndex = value.indexOf('(');
        var closeParenIndex = value.indexOf(')');
        var openBracketIndex = value.indexOf('[');
        var closeBracketIndex = value.indexOf(']');
        var openBraceIndex = value.indexOf('{');
        var closeBraceIndex = value.indexOf('}');
        var classes = [];
        var attributes = '';
        var styles = '';
        var tagName = '';
        var classList = [];
        var attributesList = [];
        var stylesList = [];
        if (openParenIndex > -1 && closeParenIndex > -1) {
            classes = value.substring(openParenIndex + 1, closeParenIndex).split(' ');
            classList = classes[0].split(')')[0].split(',');
        }
        if (openBracketIndex > -1 && closeBracketIndex > -1) {
            attributes = value.substring(openBracketIndex + 1, closeBracketIndex);
            attributesList = attributes.split(',');
        }
        if (openBraceIndex > -1 && closeBraceIndex > -1) {
            styles = value.substring(openBraceIndex + 1, closeBraceIndex);
            stylesList = styles.split(',');
        }
        var openIndexArray = [openParenIndex, openBracketIndex, openBraceIndex];
        openIndexArray = openIndexArray.filter(function (index) { return index > -1; });
        var len = openIndexArray.length;
        var min;
        if (len === 1) {
            min = openIndexArray[0];
        }
        else if (len === 2) {
            min = Math.min(openIndexArray[0], openIndexArray[1]);
        }
        else if (len === 3) {
            min = Math.min(openIndexArray[0], openIndexArray[1], openIndexArray[2]);
        }
        tagName = value.substring(0, min);
        tagName.trim();
        return ({
            tag: tagName, styles: stylesList, classes: classList,
            attributes: attributesList
        });
    };
    return FormatPainterActions;
}());
export { FormatPainterActions };
